---
import Layout from "../layouts/Layout.astro";
import { Code } from "astro:components";
import "../styles/global.css";
import { readFileSync, existsSync } from "node:fs";
import { fileURLToPath } from "node:url";

const serverJsonPath = fileURLToPath(new URL("../../../server.json", import.meta.url));
const serverJson = JSON.parse(readFileSync(serverJsonPath, "utf-8"));
const version = serverJson.version;

const curlCmd = '/bin/bash -c "$(curl -fsSL https://mirroir.dev/get-mirroir.sh)"';
const npxCmd = "npx -y mirroir-mcp install";
const brewCmd = "brew tap jfarcand/tap && brew install mirroir-mcp";

const permissionsCode = `{
  "allow": ["tap", "swipe", "type_text", "press_key", "launch_app"],
  "deny": [],
  "blockedApps": ["Wallet", "Banking"]
}`;

const skillExpo = `---
version: 1
name: Expo Go Signup + Onboarding
app: Expo Go
tags: ["expo", "signup", "onboarding"]
---

Sign up, handle error or success, then swipe through onboarding.

## Steps

1. Launch **Expo Go**
2. Wait for "LoginDemo" to appear
3. Tap "LoginDemo"
4. Tap "Sign Up"
5. Tap "Email"
6. Type "\${TEST_EMAIL}"
7. Tap "Password"
8. Type "\${TEST_PASSWORD}"
9. Tap "Create Account"
10. If "already exists" is visible:
    - Tap "Sign In Instead"
    - Tap "Email"
    - Type "\${TEST_EMAIL}"
    - Tap "Password"
    - Type "\${TEST_PASSWORD}"
    - Tap "Sign In"
11. Otherwise:
    - Wait for "Welcome" to appear
12. Verify "Welcome" is visible
13. Screenshot: "authenticated"
14. Repeat until "Get Started" is visible (max 5 iterations):
    - Swipe left
    - Screenshot: "onboarding"
15. Tap "Get Started"
16. Verify "Dashboard" is visible
17. Screenshot: "complete"`;

const skillWaze = `---
version: 1
name: Commute ETA Notification
app: Waze, Messages
tags: ["waze", "messages", "cross-app", "commute"]
---

Get ETA from Waze, text it via iMessage.

## Steps

1. Launch **Waze**
2. Wait for "Where to?" to appear
3. Tap "Where to?"
4. Tap "\${DESTINATION:-Work}"
5. Tap "Go"
6. Wait for "min" to appear
7. Remember: Read the commute ETA.
8. Press Home
9. Launch **Messages**
10. Tap "New Message"
11. Tap "To:"
12. Type "\${RECIPIENT}"
13. Tap "\${RECIPIENT}"
14. Tap "iMessage"
15. Type "On my way! ETA {eta}"
16. Press **Return**
17. Screenshot: "message_sent"`;

const skillSpotify = `---
version: 1
name: Play a Song
app: Spotify (macOS)
tags: ["spotify", "macos", "music", "multi-target"]
---

Search for a song on the Spotify macOS app and play it.

## Steps

1. Switch to target "spotify"
2. Tap "Search"
3. Wait for "What do you want to listen to?" to appear
4. Type "\${SONG:-Bohemian Rhapsody}"
5. Wait for "\${SONG:-Bohemian Rhapsody}" to appear
6. Tap "\${SONG:-Bohemian Rhapsody}"
7. Verify "Playing" is visible
8. Screenshot: "now_playing"`;

const skillsRepo = "jfarcand/mirroir-skills";
const skillsBase = `https://github.com/${skillsRepo}`;
const rawBase = `https://raw.githubusercontent.com/${skillsRepo}/main`;

interface Skill {
  name: string;
  description: string;
  app: string;
  path: string;
  category: string;
  url: string;
  rawUrl: string;
}

// Read pre-generated skills index from filesystem (produced by scripts/generate-skills-index.mjs).
// Falls back to GitHub API if the file doesn't exist, and to an empty list on error.
const indexPath = fileURLToPath(new URL("../data/skills-index.json", import.meta.url));
let skills: Skill[] = [];
let skillsAvailable = false;

if (existsSync(indexPath)) {
  try {
    skills = JSON.parse(readFileSync(indexPath, "utf-8"));
    skillsAvailable = skills.length > 0;
  } catch {
    // Corrupted file — continue with empty list
  }
}

if (!skillsAvailable) {
  // Fallback: fetch from GitHub API at build time (rate-limited)
  const ghHeaders: Record<string, string> = {
    Accept: "application/vnd.github.v3+json",
  };
  const ghToken = import.meta.env.GITHUB_TOKEN ?? process.env.GITHUB_TOKEN;
  if (ghToken) {
    ghHeaders.Authorization = `Bearer ${ghToken}`;
  }

  try {
    const treeRes = await fetch(
      `https://api.github.com/repos/${skillsRepo}/git/trees/main?recursive=1`,
      { headers: ghHeaders }
    );
    const tree = await treeRes.json();
    const yamlFiles = (tree.tree ?? []).filter(
      (f: { path: string }) => f.path.endsWith(".yaml") || f.path.endsWith(".yml")
    );

    function yamlValue(content: string, key: string): string {
      const lineMatch = content.match(new RegExp(`^${key}:\\s*(.*)$`, "m"));
      if (!lineMatch) return "";
      const rest = lineMatch[1].trim();
      if (rest && rest !== ">" && rest !== "|") return rest;
      const lines = content.split("\n");
      const startIdx = lines.findIndex((l) => l.match(new RegExp(`^${key}:`)));
      if (startIdx < 0) return rest;
      const blockLines: string[] = [];
      for (let i = startIdx + 1; i < lines.length; i++) {
        if (/^\s+\S/.test(lines[i])) {
          blockLines.push(lines[i].trim());
        } else if (lines[i].trim() === "") {
          blockLines.push("");
        } else {
          break;
        }
      }
      const firstPara: string[] = [];
      for (const line of blockLines) {
        if (line === "") break;
        firstPara.push(line);
      }
      return firstPara.join(" ");
    }

    const fetches = yamlFiles.map(async (f: { path: string }) => {
      const res = await fetch(
        `https://api.github.com/repos/${skillsRepo}/contents/${f.path}`,
        { headers: ghHeaders }
      );
      const data = await res.json();
      const content = atob(data.content.replace(/\n/g, ""));
      const parts = f.path.split("/");
      const category = parts.length > 1 ? parts.slice(0, -1).join("/") : "";
      return {
        name: yamlValue(content, "name") || f.path,
        description: yamlValue(content, "description"),
        app: yamlValue(content, "app"),
        path: f.path,
        category,
        url: `${skillsBase}/blob/main/${f.path}`,
        rawUrl: `${rawBase}/${f.path}`,
      };
    });
    skills = await Promise.all(fetches);
    skillsAvailable = skills.length > 0;
  } catch {
    // Build continues with empty list if GitHub API is unreachable
  }
}

---

<Layout
  title="mirroir-mcp — Give your AI an iPhone"
  description="MCP server that controls a real iPhone through macOS iPhone Mirroring. Screenshot, tap, swipe, type — from any MCP client."
>
  <!-- Hero -->
  <header>
    <img src={`${import.meta.env.BASE_URL}mirroir-wordmark.svg`} alt="mirroir-mcp" class="logo" width="80" height="100" />
    <h1>mirroir-mcp</h1>
    <p class="tagline">
      Give your AI an iPhone.
    </p>
    <p class="subtitle">
      We built an MCP server to control iPhones through macOS iPhone Mirroring. Then we realized the same tools &mdash; screenshot, tap, swipe, type &mdash; work on any macOS window. Same security model. Same skills. Same AI.
    </p>
  </header>

  <!-- Demo Videos -->
  <section class="demo-section">
    <h2>See it in action</h2>
    <div class="carousel demo-carousel">
      <div class="carousel-track">
        <div class="carousel-slide demo-slide">
          <h3>Login Flow</h3>
          <video loop muted playsinline>
            <source src={`${import.meta.env.BASE_URL}video1-expo-login.mp4`} type="video/mp4" />
          </video>
        </div>
        <div class="carousel-slide demo-slide">
          <h3>Cross-App Workflow</h3>
          <video loop muted playsinline>
            <source src={`${import.meta.env.BASE_URL}video2-waze-slack.mp4`} type="video/mp4" />
          </video>
        </div>
      </div>
      <button class="carousel-prev" aria-label="Previous">&#8249;</button>
      <button class="carousel-next" aria-label="Next">&#8250;</button>
      <div class="carousel-dots"></div>
    </div>
    <div class="demo-lightbox" id="demo-lightbox" role="dialog" aria-label="Video lightbox" aria-modal="true">
      <button class="lightbox-close" aria-label="Close lightbox">&times;</button>
      <video loop muted playsinline id="demo-lightbox-video"></video>
    </div>
    <script>
      // Autoplay videos only when reduced-motion is not preferred
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (!prefersReducedMotion) {
        document.querySelectorAll(".demo-slide video").forEach((vid) => {
          (vid as HTMLVideoElement).autoplay = true;
          (vid as HTMLVideoElement).play().catch(() => {});
        });
      }

      const lightbox = document.getElementById("demo-lightbox")!;
      const lbVideo = document.getElementById("demo-lightbox-video")! as HTMLVideoElement;
      const lbClose = lightbox.querySelector(".lightbox-close")! as HTMLButtonElement;
      let triggerElement: HTMLElement | null = null;

      function openLightbox(src: string, trigger: HTMLElement) {
        triggerElement = trigger;
        lbVideo.innerHTML = "";
        const source = document.createElement("source");
        source.src = src;
        source.type = "video/mp4";
        lbVideo.appendChild(source);
        lbVideo.load();
        lbVideo.play();
        lightbox.classList.add("active");
        document.documentElement.classList.add("scroll-lock");
        lbClose.focus();
      }

      function closeLightbox() {
        lightbox.classList.remove("active");
        document.documentElement.classList.remove("scroll-lock");
        lbVideo.pause();
        if (triggerElement) {
          triggerElement.focus();
          triggerElement = null;
        }
      }

      document.querySelectorAll(".demo-slide video").forEach((vid) => {
        vid.addEventListener("click", () => {
          const src = (vid as HTMLVideoElement).querySelector("source")!.src;
          openLightbox(src, vid as HTMLElement);
        });
      });

      lbClose.addEventListener("click", closeLightbox);

      lightbox.addEventListener("click", (e) => {
        if (e.target === lightbox) {
          closeLightbox();
        }
      });

      document.addEventListener("keydown", (e) => {
        if (!lightbox.classList.contains("active")) return;
        if (e.key === "Escape") {
          closeLightbox();
        }
        // Focus trap: cycle between close button and video
        if (e.key === "Tab") {
          const focusable = [lbClose, lbVideo];
          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          if (e.shiftKey) {
            if (document.activeElement === first) {
              e.preventDefault();
              last.focus();
            }
          } else {
            if (document.activeElement === last) {
              e.preventDefault();
              first.focus();
            }
          }
        }
      });
    </script>
  </section>

  <!-- Install -->
  <section id="install">
    <h2>Install mirroir-mcp <span class="version-badge">v{version}</span></h2>
    <div class="install-block">
      <code><span class="prompt">$</span> {brewCmd}</code>
      <button class="copy-btn" data-copy={brewCmd}>Copy</button>
    </div>
    <p class="alt-install">
      or via <a href="https://www.npmjs.com/package/mirroir-mcp" rel="noopener noreferrer">npx</a>:
    </p>
    <div class="install-block install-block-alt">
      <code><span class="prompt">$</span> {npxCmd}</code>
      <button class="copy-btn" data-copy={npxCmd}>Copy</button>
    </div>
    <p class="alt-install">
      or via <a href="https://mirroir.dev/get-mirroir.sh" rel="noopener noreferrer">shell script</a>:
    </p>
    <div class="install-block install-block-alt">
      <code><span class="prompt">$</span> {curlCmd}</code>
      <button class="copy-btn" data-copy={curlCmd}>Copy</button>
    </div>
  </section>

  <!-- Skills -->
  <section>
    <h2>Skills: intents, not scripts</h2>
    <p>
      Skills are SKILL.md files — YAML front matter plus numbered markdown steps — that describe automation flows as intents, not scripts.
      Steps like <code>Tap "Email"</code> don't specify coordinates — the AI finds
      the element by OCR matching and adapts to unexpected dialogs and layout changes.
      Test an app or automate your morning routine. Share them on the <a href="https://github.com/jfarcand/mirroir-skills" rel="noopener noreferrer">community repository</a>.
    </p>

    <div class="carousel skill-carousel">
      <div class="carousel-track">
        <div class="carousel-slide skill-slide">
          <h3>Branching + looping</h3>
          <Code code={skillExpo} lang="markdown" theme="github-dark" />
        </div>
        <div class="carousel-slide skill-slide">
          <h3>Cross-app workflow</h3>
          <Code code={skillWaze} lang="markdown" theme="github-dark" />
        </div>
        <div class="carousel-slide skill-slide">
          <h3>macOS window</h3>
          <Code code={skillSpotify} lang="markdown" theme="github-dark" />
        </div>
      </div>
      <button class="carousel-prev" aria-label="Previous">&#8249;</button>
      <button class="carousel-next" aria-label="Next">&#8250;</button>
      <div class="carousel-dots"></div>
    </div>

    <h2>Community skill library</h2>
    <p>
      The <a href="https://github.com/jfarcand/mirroir-skills" rel="noopener noreferrer">mirroir-skills</a> repository
      is an open collection of ready-made SKILL.md files &mdash; login flows, cross-app workflows, settings automation, and more.
      <code>$&#123;VAR&#125;</code> placeholders resolve from environment variables, so the same skill works across accounts and devices.
    </p>
    <p>
      Install the full library as a Claude Code plugin<sup>*</sup>:
    </p>
    <div class="install-block install-block-alt">
      <code><span class="prompt">$</span> claude plugin add jfarcand/mirroir-skills</code>
      <button class="copy-btn" data-copy="claude plugin add jfarcand/mirroir-skills">Copy</button>
    </div>
    <p class="install-hint">
      <sup>*</sup> Also supported by GitHub Copilot.
    </p>
    <div class="skill-search-wrap">
      <input
        type="text"
        id="skill-q"
        placeholder="Search skills... (e.g. login, slack, calendar)"
        autocomplete="off"
      />
      <ul id="skill-results"></ul>
    </div>
    <script id="skill-data" type="application/json" set:html={JSON.stringify(skills)} />
    <script define:vars={{ skillsAvailable }}>
      const skills = JSON.parse(
        document.getElementById("skill-data").textContent ?? "[]"
      );
      const indexAvailable = skillsAvailable;
      const input = document.getElementById("skill-q");
      const results = document.getElementById("skill-results");

      function clearResults() {
        while (results.firstChild) {
          results.removeChild(results.firstChild);
        }
      }

      function showStatus(message) {
        clearResults();
        const li = document.createElement("li");
        li.className = "skill-status";
        li.textContent = message;
        results.appendChild(li);
      }

      function render(matches) {
        clearResults();
        if (!indexAvailable) {
          showStatus("Skill index unavailable — try again later.");
          return;
        }
        if (!matches.length) {
          showStatus("No matching skills.");
          return;
        }
        for (const s of matches) {
          const li = document.createElement("li");

          const row = document.createElement("div");
          row.className = "skill-row";

          const nameLink = document.createElement("a");
          nameLink.href = s.url;
          nameLink.target = "_blank";
          nameLink.rel = "noopener noreferrer";
          nameLink.textContent = s.name;
          row.appendChild(nameLink);

          const appBadge = document.createElement("span");
          appBadge.className = "skill-app";
          appBadge.textContent = s.app;
          row.appendChild(appBadge);

          const dlLink = document.createElement("a");
          dlLink.className = "skill-dl";
          dlLink.href = s.rawUrl;
          dlLink.download = "";
          dlLink.title = "Download skill";
          dlLink.textContent = "\u2193";
          dlLink.rel = "noopener noreferrer";
          row.appendChild(dlLink);

          li.appendChild(row);

          if (s.description) {
            const desc = document.createElement("span");
            desc.className = "skill-desc";
            desc.textContent = s.description;
            li.appendChild(desc);
          }

          results.appendChild(li);
        }
      }

      input.addEventListener("input", () => {
        const q = input.value.toLowerCase().trim();
        if (!q) {
          clearResults();
          return;
        }
        const matches = skills.filter(
          (s) =>
            s.name.toLowerCase().includes(q) ||
            s.description.toLowerCase().includes(q) ||
            s.app.toLowerCase().includes(q) ||
            s.category.toLowerCase().includes(q)
        );
        render(matches);
      });
    </script>
  </section>

  <!-- Write → Run → Test → Diagnose pipeline -->
  <section>
    <h2>Write, run, test, diagnose</h2>
    <p>
      Write a SKILL.md, let the AI execute it via MCP tools, and it auto-compiles coordinates at the end. Replay deterministically from the CLI &mdash; no AI in the loop. When something breaks, <code>--agent</code> tells you why.
    </p>

    <div class="pipeline-grid">
      <div class="pipeline-step">
        <div class="pipeline-icon">1</div>
        <h3>Write</h3>
        <p>Author a SKILL.md &mdash; numbered steps, no coordinates.</p>
        <div class="pipeline-cmd">
          <code>vim login.md</code>
        </div>
      </div>
      <div class="pipeline-step">
        <div class="pipeline-icon">2</div>
        <h3>Run</h3>
        <p>The AI reads the skill via <code>get_skill</code>, executes each step with MCP tools, and auto-compiles coordinates at the end.</p>
        <div class="pipeline-cmd">
          <code>get_skill &rarr; record_step &rarr; save_compiled</code>
        </div>
      </div>
      <div class="pipeline-step">
        <div class="pipeline-icon">3</div>
        <h3>Test</h3>
        <p>Replay with zero OCR &mdash; pure input injection. A 10-step skill drops from 5+ seconds of OCR to under a second.</p>
        <div class="pipeline-cmd">
          <code>mirroir test login</code>
        </div>
      </div>
      <div class="pipeline-step">
        <div class="pipeline-icon">4</div>
        <h3>Diagnose</h3>
        <p>When a step fails, <code>--agent</code> compares expected vs. actual OCR and tells you the root cause and fix.</p>
        <div class="pipeline-cmd">
          <code>mirroir test --agent login</code>
        </div>
      </div>
    </div>

    <p>
      Agent diagnosis runs in two tiers: deterministic OCR analysis first (free, no API key), then optionally an AI model for richer analysis.
      Supports <a href="https://github.com/jfarcand/mirroir-mcp#agent-diagnosis" rel="noopener noreferrer">Anthropic, OpenAI, local Ollama, and CLI agents</a>.
    </p>
  </section>

  <!-- What it does -->
  <section>
    <h2>What Does mirroir-mcp Do?</h2>
    <p>28 tools exposed as an MCP server.</p>

    <div class="tool-grid">
      <div class="tool-category cat-touch">
        <h3>Touch</h3>
        <ul>
          <li><code>tap</code> <span>Tap at screen coordinates</span></li>
          <li><code>double_tap</code> <span>Double-tap for zoom or text selection</span></li>
          <li><code>long_press</code> <span>Hold for context menus</span></li>
          <li><code>swipe</code> <span>Quick flick between two points</span></li>
          <li><code>drag</code> <span>Slow drag for sliders and icons</span></li>
        </ul>
      </div>
      <div class="tool-category cat-input">
        <h3>Input</h3>
        <ul>
          <li><code>type_text</code> <span>Type text via virtual keyboard</span></li>
          <li><code>press_key</code> <span>Send special keys with modifiers</span></li>
          <li><code>shake</code> <span>Shake gesture for undo or dev menus</span></li>
        </ul>
      </div>
      <div class="tool-category cat-observe">
        <h3>Observe</h3>
        <ul>
          <li><code>screenshot</code> <span>Capture screen as PNG</span></li>
          <li><code>describe_screen</code> <span>OCR with tap coordinates</span></li>
          <li><code>start_recording</code> <span>Begin video recording</span></li>
          <li><code>stop_recording</code> <span>End recording, get file path</span></li>
          <li><code>get_orientation</code> <span>Portrait or landscape</span></li>
          <li><code>status</code> <span>Connection and device readiness</span></li>
          <li><code>check_health</code> <span>Full setup diagnostic</span></li>
        </ul>
      </div>
      <div class="tool-category cat-navigate">
        <h3>Navigate</h3>
        <ul>
          <li><code>launch_app</code> <span>Open app by name via Spotlight</span></li>
          <li><code>open_url</code> <span>Open URL in Safari</span></li>
          <li><code>press_home</code> <span>Return to home screen</span></li>
          <li><code>press_app_switcher</code> <span>Show recent apps</span></li>
          <li><code>spotlight</code> <span>Open Spotlight search</span></li>
          <li><code>scroll_to</code> <span>Scroll until element visible via OCR</span></li>
          <li><code>reset_app</code> <span>Force-quit app via App Switcher</span></li>
          <li><code>set_network</code> <span>Toggle airplane, Wi-Fi, cellular</span></li>
          <li><code>measure</code> <span>Time screen transitions</span></li>
          <li><code>list_skills</code> <span>List available skills</span></li>
          <li><code>get_skill</code> <span>Read skill with env substitution + compilation status</span></li>
          <li><code>record_step</code> <span>Record a compiled step during execution</span></li>
          <li><code>save_compiled</code> <span>Save compiled .json for zero-OCR replay</span></li>
        </ul>
      </div>
    </div>
  </section>

  <!-- Integrations -->
  <section>
    <h2>Integrations</h2>
    <p>Any MCP client that supports stdio transport — plug into your editor or build your own agent.</p>

    <div class="client-group">
      <h3>Agents</h3>
      <div class="client-list">
        <a href="https://docs.anthropic.com/en/docs/claude-code" rel="noopener noreferrer"><span>Claude Code</span></a>
        <a href="https://chatgpt.com" rel="noopener noreferrer"><span>ChatGPT</span></a>
        <a href="https://cursor.com" rel="noopener noreferrer"><span>Cursor</span></a>
        <a href="https://github.com/features/copilot" rel="noopener noreferrer"><span>GitHub Copilot</span></a>
      </div>
    </div>

    <div class="client-group">
      <h3>Frameworks</h3>
      <div class="client-list">
        <a href="https://github.com/langchain-ai/langgraph" rel="noopener noreferrer"><span>LangGraph</span></a>
        <a href="https://strandsagents.com" rel="noopener noreferrer"><span>Strands Agents</span></a>
      </div>
    </div>
  </section>

  <!-- Permissions -->
  <section>
    <h2>Fail-closed by default</h2>
    <p>
      Without a config file, only read-only tools are exposed. Mutating tools are
      hidden from the MCP client entirely — it never sees them unless you allow them.
    </p>

    <Code code={permissionsCode} lang="json" theme="github-dark" />

    <p>
      Drop this in <code>~/.mirroir-mcp/permissions.json</code> to control
      exactly which tools your AI agent can use.
    </p>
  </section>

  <!-- FAQ -->
  <section>
    <h2>FAQ</h2>
    <div class="faq-list">
      <details>
        <summary>Is this safe? Can the AI access my banking apps?</summary>
        <p>Without a config file, only read-only tools are exposed. Mutating tools require explicit opt-in. Use <code>blockedApps</code> in <code>permissions.json</code> to deny access to sensitive apps. Closing iPhone Mirroring kills all input immediately.</p>
      </details>
      <details>
        <summary>Why does my cursor jump when the AI is working?</summary>
        <p>macOS routes HID input to the frontmost app. The server must activate iPhone Mirroring before each input. Put it in a separate macOS Space to keep your workspace undisturbed.</p>
      </details>
      <details>
        <summary>Does it work with any iPhone app?</summary>
        <p>Yes. It operates at the screen level through iPhone Mirroring — no source code, SDK, or jailbreak required. If you can see it on screen, the AI can interact with it.</p>
      </details>
      <details>
        <summary>Why does it need a DriverKit virtual HID?</summary>
        <p>iPhone Mirroring ignores programmatic <code>CGEvent</code> injection — it only responds to the system HID path. The installer uses the <a href="https://github.com/pqrs-org/Karabiner-DriverKit-VirtualHIDDevice" rel="noopener noreferrer">standalone Karabiner DriverKit package</a> (just the virtual HID, no keyboard grabber). Existing Karabiner-Elements installs are detected and reused.</p>
      </details>
      <details>
        <summary>Can it control macOS apps too, not just iPhone?</summary>
        <p>Yes. Add a target in <code>.mirroir-mcp/targets.json</code> pointing at any macOS window — Spotify, Figma, Terminal, anything. The same 28 tools work on any target. Use <code>switch_target</code> to move between iPhone and macOS windows.</p>
      </details>
      <details>
        <summary>Can I restrict which tools the AI can use?</summary>
        <p>Yes. Drop a <code>permissions.json</code> with <code>allow</code> and <code>deny</code> lists. Tools not in the allow list are hidden from the MCP client entirely.</p>
      </details>
    </div>
    <p>
      <a href="https://github.com/jfarcand/mirroir-mcp/blob/main/docs/faq.md" rel="noopener noreferrer">Read the full FAQ</a>
    </p>
  </section>

  <!-- Carousel initialization -->
  <script>
    document.querySelectorAll(".carousel").forEach((carousel) => {
      const track = carousel.querySelector(".carousel-track") as HTMLElement;
      const slides = Array.from(carousel.querySelectorAll(".carousel-slide")) as HTMLElement[];
      const prevBtn = carousel.querySelector(".carousel-prev") as HTMLButtonElement;
      const nextBtn = carousel.querySelector(".carousel-next") as HTMLButtonElement;
      const dotsContainer = carousel.querySelector(".carousel-dots")!;

      if (slides.length < 2) {
        prevBtn.style.display = "none";
        nextBtn.style.display = "none";
        dotsContainer.remove();
        return;
      }

      let currentIndex = 0;

      slides.forEach((_, i) => {
        const dot = document.createElement("button");
        dot.classList.add("carousel-dot");
        dot.setAttribute("aria-label", `Go to slide ${i + 1}`);
        if (i === 0) dot.classList.add("active");
        dot.addEventListener("click", () => goTo(i));
        dotsContainer.appendChild(dot);
      });

      function goTo(index: number) {
        currentIndex = Math.max(0, Math.min(index, slides.length - 1));
        track.scrollTo({
          left: slides[currentIndex].offsetLeft - track.offsetLeft,
          behavior: "smooth",
        });
        updateUI();
      }

      function updateUI() {
        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === slides.length - 1;
        dotsContainer.querySelectorAll(".carousel-dot").forEach((dot, i) => {
          dot.classList.toggle("active", i === currentIndex);
        });
      }

      prevBtn.addEventListener("click", () => goTo(currentIndex - 1));
      nextBtn.addEventListener("click", () => goTo(currentIndex + 1));

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const index = slides.indexOf(entry.target as HTMLElement);
              if (index >= 0) {
                currentIndex = index;
                updateUI();
              }
            }
          });
        },
        { root: track, threshold: 0.6 }
      );
      slides.forEach((slide) => observer.observe(slide));

      updateUI();
    });
  </script>

  <!-- Footer -->
  <footer>
    <p>
      Why "mirroir"? It's the old French spelling of <em>miroir</em> (mirror) — a nod to the author's roots, not a typo.
    </p>
    <p>
      <a href="https://github.com/jfarcand/mirroir-mcp">GitHub</a> &middot;
      <a href="https://github.com/jfarcand/mirroir-mcp#readme">Docs</a> &middot;
      <a href="https://github.com/jfarcand/mirroir-mcp/discussions/1">Community</a> &middot;
      <a href="https://github.com/sponsors/jfarcand">Sponsor</a> &middot;
      Apache-2.0 &middot;
      macOS 15+
    </p>
  </footer>
</Layout>
